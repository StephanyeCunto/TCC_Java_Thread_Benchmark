% Adaptado para uso no DACC - IF Sudeste MG, campus Rio Pomba
% ABNT NBR 6023/2025, 14724/2024, 10520/2023 - Trabalhos academicos
%Atualizado em agosto de 2025 (Alessandra Martins Coelho)

\documentclass[12pt, openright, oneside, a4paper, english,	french,	spanish, brazil	]{abntex2}

\usepackage{fontspec}
\setmainfont{Arial}
\setsansfont{Arial}
\bibliographystyle{abntex2-alf-antigo}
\usepackage[alf]{abntex2cite}	
\renewcommand\UrlFont{\normalfont} 
\usepackage{lmodern}
\usepackage[T1]{fontenc}		
\usepackage[utf8]{inputenc}		
\usepackage{indentfirst}		
\usepackage{color}				
\usepackage{graphicx}			
\usepackage{microtype} 			
\usepackage{lipsum}				
\usepackage{verbatimbox}
\usepackage{cmap}				
\usepackage{lastpage}			
\usepackage{xcolor}	
\usepackage{underscore}         
\usepackage{multicol}          
\usepackage{placeins}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{pdfpages}
\usepackage{float}
\usepackage{caption}

\titulo{ESCREVER O TÍTULO AQUI} 
\autor{STEPHANYE CRISTINE ANTUNES DE CUNTO} 
\local{RIO POMBA - MG}
\orientador{ME. BIANCA PORTES DE CASTRO} 
\coorientador{DR. JOSÉ RUI CASTRO DE SOUSA}
\tipotrabalho{Trabalho de Conclusão de Curso}
\preambulo{Trabalho de Conclusão de curso apresentado ao \textit{Campus} Rio Pomba, do Instituto Federal de Educação, Ciência e Tecnologia do Sudeste de Minas Gerais, como parte das exigências do curso de Bacharelado em Ciência da Computação para a obtenção do título de Bacharel em Ciência da Computação.}

\definecolor{blue}{RGB}{41,5,195}

\makeatletter
    \hypersetup{ 
        pdftitle={\@title}, pdfauthor={\@author}, pdfsubject={\imprimirpreambulo}, pdfcreator={\@author},
        pdfkeywords={ciência da computação}{trabalho acadêmico}{constraint programming}{programação por restrições}{examination timetabling}, 
        colorlinks=true, linkcolor=black, citecolor=black, filecolor=black, urlcolor=black, bookmarksdepth=4       	
    }
\makeatother

\makeatletter
    \setlength{\@fptop}{5pt}
\makeatother

\newcommand{\ignore}[1]{}

\newcommand{\quadroname}{Quadro}
\newcommand{\listofquadrosname}{Lista de quadros}

%\newfloat[chapter]{quadro}{loq}{\quadroname} % ver depois erro abntex2.cls
\newfloat{quadro}{htbp}{loq}[section]
\newlistof{listofquadros}{loq}{\listofquadrosname}
\newlistentry{quadro}{loq}{0}

\setfloatadjustment{quadro}{\centering}
\counterwithout{quadro}{chapter}
\renewcommand{\cftquadroname}{\quadroname\space} 
\renewcommand*{\cftquadroaftersnum}{\hfill--\hfill}

\setfloatlocations{quadro}{hbtp} 

\setlength{\parindent}{1.3cm}
\setlength{\parskip}{0.2cm}  

\makeindex

\DeclareCaptionLabelSeparator{barr}{\space\textendash\space}

% quadro sempre com legenda acima
%\captionsetup[quadro]{position=top}% 

% no preâmbulo, junto ao seu setup de caption
\captionsetup[quadro]{%
  position=top, justification=raggedright, singlelinecheck=false         
}

\begin{document}

    \captionsetup{ font= small, labelfont=bf, textfont=small, labelsep=barr, justification=justified, singlelinecheck=false }

    \selectlanguage{brazil}

    \frenchspacing 

    \begin{center}
        \textbf{ 
            INSTITUTO FEDERAL DE EDUCAÇÃO, CIÊNCIA E TECNOLOGIA DO SUDESTE DE MINAS GERAIS - CAMPUS RIO POMBA
        }
    \end{center}

    \imprimircapa
    \imprimirfolhaderosto*

    \begin{fichacatalografica}
        \vspace*{\fill}					
        \hrule							
        \begin{center}					
            \begin{minipage}[c]{12.5cm}		
            
                FICHA CATALOGRÁFICA TEMPORÁRIA \\
                \imprimirautor
                
                \hspace{0.5cm} \imprimirtitulo  / \imprimirautor. --
                \imprimirlocal, \imprimirdata-

                \hspace{0.5cm} \imprimirorientadorRotulo~\imprimirorientador\\
                
                \hspace{0.5cm}
                \parbox[t]{\textwidth}{%
                    \normalsize
                    \imprimirtipotrabalho~--~Instituto Federal de Educação, Ciência e Tecnologia do Sudeste de Minas, Campus Rio Pomba
                }

            \end{minipage}
        \end{center}
        \hrule
    \end{fichacatalografica}

    \begin{folhadeaprovacao}

        \begin{center}
            {\ABNTEXchapterfont\normalsize\imprimirautor}

            \vspace*{\fill}\vspace*{\fill}
            {\ABNTEXchapterfont\bfseries\normalsize\imprimirtitulo}
            \vspace*{\fill}
            
            \hspace{.45\textwidth}
            \begin{minipage}{.5\textwidth}
                \imprimirpreambulo
            \end{minipage}%
            \vspace*{\fill}
        \end{center}
            
        Trabalho aprovado em XX de XXXXX de XXXX.

        \assinatura{\textbf{\imprimirorientador} \\Orientadora, IF Sudeste MG - Rio Pomba} 
        \assinatura{\textbf{\imprimircoorientador} \\Coorientador, IF Sudeste MG - Rio Pomba}
        \assinatura{\textbf{TÍTULO E NOME DO MEMBRO DA BANCA} \\ IF Sudeste MG - Rio Pomba}
        
        \begin{center}
            \vspace*{0.5cm}
            {\normalsize\imprimirlocal}
            \par
            {\normalsize\imprimirdata}
            \vspace*{1cm}
        \end{center}
    
    \end{folhadeaprovacao}

    % \begin{dedicatoria}
    %     \vspace*{\fill}
    %     \begin{flushright}
    %         \hspace*{4cm}
    %         \parbox{11.2cm}{
    %             \raggedleft 
    %             \textit{
    %             }
    %         }
    %     \end{flushright}
    % \end{dedicatoria}

    % \begin{agradecimentos}
    %     Agradecimentos
    % \end{agradecimentos}

    \begin{epigrafe}
        \vspace*{\fill}
     	\begin{flushright}
      		\textit{
                ``Os olhos não são apenas\\
      		    o espelho da alma,\\
      		    mas também do corpo.''\\
      		    (Ignatz von Peczelly, 1989)
            }
     	\end{flushright}
     \end{epigrafe}

    \begin{resumo}
        O resumo é um texto breve que apresenta, de forma clara e objetiva, os principais elementos da monografia. Ele deve permitir que o leitor compreenda rapidamente sobre o que é o trabalho, qual foi a abordagem adotada e quais foram os resultados e conclusões.
        Na ABNT (NBR 6028), recomenda-se que o resumo seja escrito em parágrafo único, sem subdivisões e sem citações diretas, geralmente com 150 a 500 palavras. O que incluir no resumo: Tema e objetivo – Apresente o assunto principal e o objetivo geral do trabalho; 
            Metodologia – Informe de forma resumida o método, técnicas ou procedimentos utilizados; Resultados – Destaque os resultados mais relevantes obtidos na pesquisa; 
            Conclusão – Apresente a principal contribuição ou conclusão do estudo. Dicas importantes: Escreva no tempo passado, já que o trabalho foi realizado. Evite usar abreviações pouco conhecidas ou siglas sem explicação. Não insira informações que não estejam no corpo do trabalho. Revise para garantir clareza, coerência e objetividade.
        Lembre-se de incluir palavras-chave logo abaixo do resumo (entre três e cinco termos que representem bem o conteúdo do trabalho, separados com ponto e vírgula). Importante: O resumo deve ser escrito após a conclusão do trabalho, quando todos os resultados já estão definidos. Assim, será fiel ao conteúdo final da monografia.

        \noindent \textbf{Palavras-Chave:} 
    \end{resumo}


    \begin{resumo}[Abstract]
        \begin{otherlanguage*}{english}
            Tradução do resumo para a língua inglesa.
                
            \noindent\textbf{Key-words}: 
        \end{otherlanguage*}
    \end{resumo}

    % \pdfbookmark[0]{\listfigurename}{lof}
    % \listoffigures*
    % \cleardoublepage

    % \pdfbookmark[0]{\listofquadrosname}{loq}
    % \listofquadros*
    % \cleardoublepage
    % \pdfbookmark[0]{\listtablename}{lot}
    % \listoftables*
    % \cleardoublepage

    \begin{siglas}
        \item[CPU]     Unidade Central de Processamento
        \item[I/O]     Entrada/Saída
        \item[JVM]     Java Virtual Machine (Máquina Virtual Java)
        \item[SO]      Sistema Operacional
        \item[SPD]     Sistemas Paralelos E Distribuídos


        \item[XXX]     INSERIR EM ORDEM ALFABÉTICA

    \end{siglas}

    % \begin{simbolos}
    %     \item[$ \Lambda $] Lambda
    % \end{simbolos}

    \pdfbookmark[0]{\contentsname}{toc}
    \tableofcontents*
    \cleardoublepage

    \textual
    % \setcounter{page}{14} 
 
    \chapter{Introdução}
    \markright{Introdução}
    \label{chapter:introducao}
    
        Uma thread é a menor unidade de processamento existente dentro de um processo. Cada processo é capaz de conter múltiplas threads, permitindo a execução simultânea de diferentes partes de um programa ou de diferentes tarefas \cite{silberschatz2018operating}.

        A utilização de threads oferece diversos benefícios em problemas que envolvem tarefas de alto processamento (\textit{CPU-bound}) e operações de entrada e saída (\textit{I/O-bound}). Além disso, em sistemas reativos e servidores, threads permitem que aplicações atendam múltiplos usuários simultaneamente, mantendo respostas rápidas e contínuas mesmo sob alta carga, garantindo desempenho eficiente e melhor experiência ao usuário. Assim, o uso de threads é aplicado como estratégia para otimizar recursos computacionais e melhorar a eficiência de sistemas em diferentes contextos.
        
        O relatório \textit{State of the Octoverse 2024} \cite{github2024octoverse} demonstra que a linguagem de programação Java está entre as cinco linguagens mais utilizadas na plataforma, o que reforça sua importância como uma das principais tecnologias do desenvolvimento de software.

        No lançamento da versão 19 do Java, foram introduzidas as threads virtuais, que, diferente das threads tradicionais, são gerenciadas pela \textit{Java Virtual Machine} (JVM). Enquanto o escalonamento das threads tradicionais é realizado pelo sistema operacional (SO), determinando quando cada thread é executada, o escalonamento das threads virtuais é feito pela própria JVM, podendo apresentar comportamentos distintos \cite{oracleVirtualThreads}. 

        O uso de threads tradicionais pode gerar \textit{overhead} e limitar a escalabilidade. Dessa forma, as threads virtuais surgem como alternativa para contornar essas limitações. Este trabalho investiga como a utilização de threads virtuais impacta o desempenho e a escalabilidade de aplicações concorrentes.

        O objetivo deste trabalho é analisar as diferenças de desempenho entre threads tradicionais e threads virtuais, avaliando como cada abordagem impacta a execução de aplicações concorrentes.

        Para alcançar o objetivo geral, foram definidos os seguintes objetivos específicos:

        \begin{itemize}
            \item Compreender os fundamentos teóricos da programação concorrente e das diferentes abordagens de threads;
            \item Implementar protótipos de aplicações concorrentes utilizando ambas as abordagens;
            \item Medir e comparar métricas de desempenho;
            \item Analisar os resultados obtidos, identificando vantagens e limitações.
        \end{itemize}

        A escolha deste tema parte do interesse gerado durante a disciplina de Sistemas Paralelos e Distribuídos (SPD), na qual foram estudados os conceitos fundamentais de concorrência, paralelismo e gerenciamento de threads. Além disso, o apreço pessoal pela linguagem Java contribuiu para a definição do tema, considerando que a plataforma tem investido em melhorias relacionadas à programação concorrente. Dessa forma, esse trabalho se justifica pelo interesse acadêmico adquirido ao longo da disciplina e pela pertinência de investigar uma inovação recente da linguagem Java, contribuindo para a compreensão de como esse novo modelo de threads pode aprimorar o desempenho de aplicações concorrentes.  
        
        Este trabalho está organizado da seguinte forma:

        \begin{itemize}
            \item \hyperref[chapter:introducao]{\textbf{Seção 1 - Introdução:} Apresenta o tema, os objetivos e a justificativa.}
            
            \item \hyperref[chapter:fundamentacaoTeorica]{\textbf{Seção 2 - Fundamentação teórica:} Expõe os conceitos de concorrência e paralelismo e descreve o funcionamento de processos, threads tradicionais e threads virtuais.}
            
            \item \hyperref[chapter:trabalhos]{\textbf{Seção 3 - Trabalhos Relacionados:} Revisa estudos anteriores sobre o desempenho de threads tradicionais e threads virtuais.}
            
            \item \hyperref[chapter:metodologia]{\textbf{Seção 4 - Metodologia:} Detalha como os testes foram conduzidos e como os dados foram coletados.}
            
            \item \hyperref[chapter:resultados]{\textbf{Seção 5 - Resultados e Discussão:} Apresenta e analisa os dados obtidos durante os testes.}
           
            \item \hyperref[chapter:conclusao]{\textbf{Seção 6 - Conclusão:} Expõe as considerações finais do estudo.}
        \end{itemize}


        Por fim, são listadas as referências bibliográficas utilizadas no trabalho, seguidas pelos apêndices e anexos que complementam o estudo.


    % A introdução é a primeira parte do texto e tem como objetivo apresentar, de forma clara e objetiva, o tema e o contexto da pesquisa. Ela deve despertar o interesse do leitor e situá-lo quanto à relevância do trabalho. Geralmente, a introdução contém:

    %    Contextualização – Apresente o tema no cenário em que ele está inserido, destacando dados, fatos ou informações que ajudem a compreender sua importância.

    %   Problema de Pesquisa – Indique claramente a questão que motivou o estudo, explicitando qual lacuna ou necessidade será abordada.

    %   Justificativa – Explique a relevância do trabalho, tanto acadêmica quanto prática, e por que ele merece ser desenvolvido.

    %   Objetivos – Informe o objetivo geral e, se necessário, os objetivos específicos, que detalham as etapas para alcançar o resultado pretendido.

    %   Estrutura do Trabalho – Descreva brevemente como o texto está organizado, citando os capítulos ou seções.

    %   A introdução não deve apresentar resultados, conclusões ou discussões. Ela prepara o terreno para o desenvolvimento do trabalho.
    %   Normalmente, é escrita no final da monografia, quando o autor já tem clareza total sobre todo o conteúdo.

    % ---------------------------------------------------------------------------------------------
    % Fundamentação Teórica
    % ---------------------------------------------------------------------------------------------

    \setcounter{chapter}{1}
    \chapter{Fundamentação Teórica}
    \label{chapter:fundamentacaoTeorica}

        Exemplo de citação no final do texto \cite{pecb2022iso27002}. 

        Exemplo de citação dentro do texto \citeonline{pecb2022iso27002}.

        Exemplo de uma Figura. Use ref para chamá-la no texto. Figura \ref{fig:figura1}.
        
    \begin{figure}[h]
        \centering
        \begin{minipage}{0.5\textwidth}
            \phantomsection
            \fontsize{10}{12}\selectfont
            \caption{Pilares da Segurança da Informação.}
            \includegraphics[width=1\linewidth]{imagens/Figura 1.png}
            \caption*{\raggedright\small \textbf{Fonte}: \citeonline{bughunt2023triade}.}
            \label{fig:figura1}
        \end{minipage}
    \end{figure}

    \section{Para criar um título} 
        Sempre inserir um texto entre os Títulos

    \subsection{mais um título}

    Um exemplo de Quadro (Quadro \ref{quad: quadro1}). 

    \begin{quadro}[ht]
    \centering
    \begin{minipage}{0.80\textwidth}
    \phantomsection
    \fontsize{10}{12}\selectfont
    \caption{Panorama dos ataques baseados em engenharia social.} 
    \begin{tabularx}{\textwidth}{|l|X|}\hline
        Categoria           & Resultado                                                        \\ \hline
        Frequência          & 3.661 incidentes, sendo (82,8\%) com vazamento confirmado de dados.    \\ \hline
        Atores de ameaça    & (100\%) externos (\textit{breaches}).                                        \\ \hline
        Motivações          & (95\%) financeiras, (5\%) espionagem (\textit{breaches}).                      \\\hline
        Dados comprometidos & Credenciais (50\%), pessoais (41\%), internos (20\%), outros (14\%). \\ \hline
    \end{tabularx}
    \label{quad: quadro1}
    %\vspace{0.5em}
    \caption*{\raggedright\small \textbf{Fonte}: \citeonline{verizon2024dbir}, adaptado.}
    \end{minipage}
    \end{quadro}

    Um exemplo de Tabela.

    \begin{table}[ht]
    \centering
    \begin{minipage}{0.60\textwidth}
    \phantomsection
    \fontsize{10}{12}\selectfont
    \caption{Notificações formais de incidentes e vulnerabilidades em órgãos públicos entre 2021 e 2025.}
    \label{tab:1}
    \begin{tabular}{cccc}
        \toprule
        Ano & Vulnerabilidades & Incidentes & Total de notificações \\
        \midrule
        2025 & 1994 & 4859 & 6853 \\
        2024 & 5115 & 9803 & 14918 \\
        2023 & 10225 & 4905 & 15130 \\
        2022 & 5128 & 3402 & 8530 \\
        2021 & 4964 & 4903 & 9867 \\ \hline
        Total & 27426 & 27872 & 55298 \\
        \bottomrule
    \end{tabular}
        \caption*{\raggedright\small \textbf{Fonte}: \citeonline{ctirgov2025numeros}.}
        \label{quad:cronograma_otimo}
    \end{minipage}
    \end{table}

    \subsubsection{O que escrever na Fundamentação Teórica}

    A Fundamentação Teórica é a base conceitual do seu trabalho. Nela, você apresenta, discute e analisa as teorias, conceitos, modelos e estudos já existentes que sustentam a sua pesquisa.

    Incluir conceitos e definições – Explique os principais termos, conceitos e elementos que serão usados no trabalho, sempre com referência a autores da área.

    Modelos, teorias e abordagens – Traga as principais correntes teóricas que embasam seu estudo.

    Dicas importantes:

        \begin{itemize}
            \item Sempre cite as fontes de onde retirou as informações (seguindo as normas da ABNT).
            \item Organize o texto de forma lógica, por temas ou subtemas, evitando apenas listar autores.
            \item Não copie trechos longos; prefira escrever com suas palavras e citar corretamente.
            \item Evite incluir opiniões pessoais — mantenha o foco no que já foi publicado por outros autores.
        \end{itemize}

        Relacionamento com o seu trabalho – Mostre como essas teorias e estudos se aplicam ou se relacionam com a sua pesquisa.


    \chapter{Trabalhos Relacionados}
    \label{chapter:trabalhos}

    Esta seção apresenta trabalhos que servem de base para a pesquisa sobre threads tradicionais e threads virtuais em Java. São discutidos estudos anteriores que investigaram o desempenho dessas threads. Com a revisão realizada, é possível compreender as abordagens utilizadas, os resultados obtidos e as lacunas existentes, fornecendo um referencial teórico sólido para os testes conduzidos neste trabalho.

    \section{Benchmarking the Performance of Java Virtual Threads in High-Throughput Workloads}
        \citeonline{Pandita2024} apresentou uma comparação entre threads virtuais e threads tradicionais, considerando escalabilidade, utilização de recursos e latência em cargas de trabalho de alto rendimento. Foram realizados dois benchmarks: CPU-bound, envolvendo cálculos de números primos, e I/O-bound, simulando operações de bloqueio entre duas aplicações Java em ambiente AWS EC2.

        Os resultados mostraram que, em tarefas com baixo uso de CPU, ambos os modelos apresentam desempenho semelhante. Em cenários intensivos de CPU, a limitação dos recursos computacionais restringe o aumento da simultaneidade. Por outro lado, em operações I/O-bound, threads virtuais se destacaram, oferecendo maior simultaneidade, redução do consumo de memória e melhor aproveitamento da CPU. Esses dados reforçam a eficiência das threads virtuais em operações de I/O e fornecem um referencial relevante para estudos comparativos, como o presente trabalho.

    \section{Uma análise comparativa entre threads e green threads no Java}
        \citeonline{Souto2024} realizou uma pesquisa comparando o desempenho de threads tradicionais e threads virtuais. O estudo analisou operações fundamentais de gerenciamento
        de threads, o tempo necessário para instanciá-las, iniciá-las, finalizá-las e realizar a troca de contexto em ambas. Para isso, foram utilizados testes com diferentes quantidades de threads e a biblioteca JMH do JDK para coleta precisa de tempos de execução.

        O estudo demonstrou que, nos cenários testados, as threads virtuais podem ser mais de 100 vezes mais rápidas que as threads tradicionais, evidenciando sua eficiência em operações de criação, inicialização, finalização e mudança de contexto.  Apesar do alto desempenho observado, o estudo se concentrou em cenários específicos, abrindo espaço para pesquisas adicionais que explorem diferentes cargas de trabalho e padrões de uso de threads, como os apresentados neste trabalho.

    \section{Comparison of Concurrency Technologies in Java}
        Em seu trabalho, \citeonline{GustafssonPersson2024} realizou quatro benchmarks com o objetivo de comparar o desempenho entre threads tradicionais, threads virtuais e Reactive Framework em testes de I/O-bound (simulado), CPU-bound e testes mistos.

        No teste I/O-bound, utilizou-se o mecanismo Thread.sleep(100 ms) para simular tempos de espera. No teste CPU-bound, realizou-se a multiplicação de matrizes 200x200. Os dois testes mistos combinaram cálculos de matrizes e pausas: um focado em I/O-bound multiplicando matrizes 50x50 com pausa de 100 ms, e outro focado em CPU-bound multiplicando matrizes 200x200 com pausa de 50 ms.

        Os resultados indicaram que, no teste CPU-bound, threads tradicionais apresentaram melhor desempenho em termos de throughput e latência. No teste I/O-bound, o Reactive Framework se destacou, mostrando maior escalabilidade e menor uso de CPU e memória. Nos testes mistos, threads virtuais obtiveram alta taxa de requisições e baixa latência no cenário CPU-bound, mantendo desempenho elevado no cenário I/O-bound, enquanto threads tradicionais apresentaram maior latência e menor throughput. O que torna nótorio que a eficácia das threads virtuais em cenários mistos, evidenciando seu potencial em aplicações que demandam simultaneidade e eficiência de recursos. 

    \section{Avaliação dos mecanismos de concorrência na API do Java 8}
        Uma análise comparativa do desempenho de single thread, threads, ExecutorService e Fork/Join em algoritmos de ordenação foi realizada por \citeonline{Aguas2015} , utilizando os algoritmos Quicksort, Merge-sort e Pigeonhole Sort. Os testes foram conduzidos em três máquinas com processadores diferentes (Dual-Core, i5 e i7), e cada algoritmo foi executado 60 vezes para cada abordagem de concorrência.

        O Quicksort executado com ForkJoin-Pool em uma máquina com 8 processadores lógicos apresentou o melhor desempenho em termos de tempo. De forma geral, Quicksort combinado com ForkJoin-Pool registrou os menores tempos na maioria dos cenários testados. O estudo demonstrou que a máquina com maior número de processadores lógicos obteve os melhores resultados, comprovando que a execução paralela se beneficia diretamente da disponibilidade de mais núcleos para distribuir as tarefas simultaneamente.

        Esse trabalho evidencia a importância da escolha adequada de técnicas de concorrência e da arquitetura de hardware para otimização do desempenho em algoritmos paralelos.
    
    \section{Síntese dos Trabalhos Relacionados}

    Observa-se na literatura um crescente enfoque em threads virtuais e tradicionais em Java.

    Em seu texto \citeonline{Souto2024} concentrou-se na análise das operações de criação, inicialização, finalização e troca de contexto, onde se nota que threads virtuais podem ser mais de 100 vezes mais rápidas que threads tradicionais em cenários específicos. Por sua vez \citeonline{Pandita2024} aprofunda essa análise ao avaliar o desempenho em cargas CPU-bound e I/O-bound, onde nota-se que, em tarefas com baixo uso de CPU, o desempenho é semelhante, porém threads virtuais se destacam em operações I/O, oferecendo maior simultaneidade, redução do consumo de memória e melhor aproveitamento da CPU.

    \citeonline{GustafssonPersson2024} expandiu a análise incluindo o Reactive Framework e cenários mistos, mostrando que threads virtuais apresentam alta taxa de requisições e baixa latência em cenários combinados de CPU e I/O, enquanto threads tradicionais apresentam limitações de throughput e latência. Enquanto \citeonline{Aguas2015} avaliou abordagens de concorrência na execução de algoritmos de ordenação, deixando claro que a execução paralela se beneficia diretamente do aumento do número de núcleos, principalmente quando combinada com ForkJoin-Pool, o que demonstra a importância do alinhamento entre técnicas de concorrência e arquitetura de hardware.

    A comparação desses estudos permite identificar padrões: threads virtuais oferecem vantagens em simultaneidade e eficiência de recursos, especialmente em operações de I/O ou cenários mistos, enquanto threads tradicionais ainda podem apresentar desempenho competitivo em tarefas CPU-bound simples.

    O presente trabalho se apoia nesses estudos como referencial para analisar o desempenho de threads tradicionais e virtuais em Java, destacando diferenças de comportamento em operações básicas de criação, execução e finalização de threads. Dessa forma, busca-se fornecer uma compreensão prática sobre a eficiência e o uso de recursos dessas duas abordagens de concorrência em cenários controlados.
  
    \ignore{
        A seção Trabalhos Relacionados apresenta estudos, projetos ou soluções já desenvolvidos que tratam de problemas semelhantes ou próximos ao do seu trabalho. O objetivo é mostrar o que já foi feito, quais métodos foram usados e onde ainda existem lacunas que justificam sua pesquisa.

        O que incluir:
            \begin{enumerate}
                \item Seleção dos trabalhos – Escolha pesquisas, artigos, relatórios ou projetos relevantes e recentes, de preferência de fontes acadêmicas confiáveis.
                \item Breve descrição – Explique, de forma sucinta, o objetivo, metodologia e resultados de cada trabalho analisado.
                \item Comparação – Mostre similaridades e diferenças entre os trabalhos existentes e o seu.
                \item Identificação de lacunas – Destaque aspectos que não foram explorados ou limitações nas pesquisas anteriores que o seu trabalho pretende abordar.
            \end{enumerate}

        Dicas importantes:

            \begin{itemize}
                \item Organize a apresentação dos trabalhos por tema, abordagem ou cronologia, para manter a lógica do texto.
                \item Utilize citações corretas, conforme a ABNT.
                \item Evite apenas listar trabalhos; faça conexões entre eles e explique a relevância para a sua pesquisa.
                \item Seja objetivo — não é necessário descrever cada detalhe técnico de outros trabalhos, apenas o suficiente para contextualizar sua comparação.
                \item Importante: Ao final dessa seção, o leitor deve entender em que contexto seu trabalho se encaixa e por que ele é necessário, mesmo diante de outras pesquisas já realizadas.
            \end{itemize}
    }

    \chapter{Metodologia}  
    \label{chapter:metodologia}

    Essa seção descreve a metodologia adotada para comparar o desempenho entre \textit{threads} tradicionais e \textit{threads} virtuais em Java. Os experimentos foram baseados no trabalho de \citeonline{GustafssonPersson2024}, como adaptações para o contexto e ambiente deste estudo.

    A abordagem envolveu a implementação de um servidor HTTP simples utilizando arquitetura cliente-servidor, onde o servidor foi configurado para utilizar \textit{threads} tradicionais e \textit{threads} virtuais. Dois tipos de testes foram conduzidos: testes de carga constante para avaliar estabilidade ao longo do tempo, e testes de aumento gradual para identificar limites de escalabilidade. As seções seguintes detalham a metodologia adotada.

    Os experimentos foram projetados para comparar o comportamento de \textit{threads} tradicionais e \textit{threads} sob condições controladas, focando em desempenho (latência e throughput), consumo de recursos (CPU e memória) e escalabilidade (capacidade de processamento simultâneo).

    Para garantir condições equivalentes entre os dois mecanismos de \textit{threads} os experimentos foram conduzidos nas seguintes condições: mesma infraestrutura de hardware, mesmas configurações de sistema operacional, mesma implementação de servidor e mesma metodologia de geração de carga. A ordem de execução foi alternada entre threads tradicionais e virtuais para minimizar vieses relacionados ao aquecimento da JVM ou estado do sistema.

    Todos os experimentos seguiram um protocolo automatizado que incluia fases de aquecimento (\textit{warmup}), coleta manual de lixo (\textit{garbage collection}) e pausas entre testes.Esse protocolo, detalhado nas seções subsequentes, teve como objetivo isolar o impacto do mecanismo de threads de outros fatores que poderiam influenciar os resultados.

    \section{Ambiente de Teste}
    Nesta seção, são descritas as características do ambiente utilizado para a realização dos experimentos, incluindo a configuração de hardware, software e rede.

    Os testes utilizaram uma arquitetura cliente-servidor, como duas máquinas conectadas por uma rede Wi-fi local. A máquina servidor hospedava a aplicação Java, enquanto a máquina cliente era responsável por gerar carga e coletar métricas de desempenho. 

    Ambas as máquinas foram dedicadas exclusivamente à execução dos experimentos, sem aplicações ou serviços concorrentes em execução, reduzindo interferências no uso de CPU, memória e rede.

    A máquina servidora possuía as seguintes características:

    \begin{itemize}
        \item Processador: Apple M2 (8 núcleos)
        \item Memória RAM: 8~GB
        \item Sistema Operacional: macOS Tahoe (versão 26)
        \item Java Development Kit (JDK): versão 21 LTS
        \item Spring Boot: versão 3.3.2 (obs.: verificar versão)
        \item Conexão de rede: Wi-fi 50~Mbps
    \end{itemize}

    A máquina cliente possuía as seguintes especificações:

    \begin{itemize}
    \item Processador: Intel Core i5-2410M (2 núcleos, 4 threads)
    \item Memória RAM: 8~GB
    \item Sistema Operacional: Ubuntu 22.04 LTS
    \item Ferramenta de carga: Vegeta (versão 12.13.0)
    \item Conexão de rede: Wi-fi 50~Mbps
    \end{itemize}

    Todos os experimentos foram realizados com a comunicação entre servidor e cliente por rede Wi-fi o que pode introduzir variações adicionais de latência. Entretanto, como ambos os mecanismos de threads foram avaliados sob as mesmas condições, esse impacto é considerado equivalente para fins comparativos.

    Para evitar que o sistema operacional se tornasse um gargalo durante os experimentos, foram aplicadas configurações específicas em ambas as máquinas. Essas configurações visaram garantir que limitações observadas estivessem associadas ao mecanismo de gerenciamento de threads, e não a restrições impostas pelo sistema operacional ou pela pilha de rede.

    \begin{itemize}
        \item  Número máximo global de arquivos abertos no sistema (1048576), cada conexão TCP consome um descritor de arquivo o que poderia limitar o número de conexões simultâneas.
        \item  Número máximo de arquivos abertos por processo (1048576), garantindo que o servidor possa abrir muitos arquivos e conexões de rede simultaneamente.
        \item  Tamanho máximo da fila de conexões pendentes (4096), permitindo que o servidor aceite um grande número de conexões simultâneas.
        \item  Tamanho máximo do buffer de socket (8 MB), otimizando a transferência de dados pela rede.
        \item  Número máximo de processos por usuário (2000), garantindo que o servidor possa criar muitas threads conforme necessário.
        \item  Tamanho do buffer de envio e recebimento TCP (2 MB), otimizando a transferência de dados pela rede.
        \item  Tempo que conexões TCP permanecem em estado TIME_WAIT (250 ms), liberando recursos mais rapidamente.
        \item  Desativação do ACK atrasado do TCP, reduzindo a latência em conexões de rede.
        \item  Faixa de portas TCP (1024 a 65.535), evita esgotamento de portas efêmeras.
    \end{itemize}

    As configurações da JVM foram mantidas em seus valores padrão para refletir cenários reais de uso.

    \section{Implementação do Servidor}

    Foi desenvolvido um servidor HTTP simples utilizando o framework Spring Boot. A escolha do Spring Boot se deve à facilidade de uso para a criação rápida de aplicações web em Java e sua popularidade, sendo listado entre os frameworks web mais populares em pesquisas, como a \citeonline{stackoverflowSurvey2025}.

    O servidor foi implementado de forma a suportar threads tradicionais e threads virtuais, permitindo a comparação direta entre os dois mecanismos.


    Para evitar que o servidor se tornasse um gargalo durante os experimentos, foram aplicadas configurações no Spring Boot que permitem alto nível de concorrência:
    \begin{itemize}
        \item \texttt{server.tomcat.max-threads=50000}: Define o número máximo de threads que o servidor pode criar para processar requisições.
        \item \texttt{server.tomcat.accept-count=20000}: Define o tamanho da fila de conexões pendentes.
        \item \texttt{server.tomcat.connection-timeout=5000}: Define o tempo máximo em milissegundos que o servidor espera por uma conexão.
        \item \texttt{spring.threads.virtual.enabled=true}: Habilita o uso de threads virtuais no Spring Boot.
    \end{itemize}

    O servidor expõe três endpoints REST:

    \begin{itemize}
        \item \texttt{/threads/traditional}: Processa requisições utilizando threads tradicionais do sistema operacional. Cada requisição inicia uma thread que aguarda 100 ms antes de responder com status HTTP 200.
        \item \texttt{/threads/virtual}: Processa requisições utilizando threads virtuais do Project Loom. A lógica de processamento é idêntica ao endpoint tradicional, diferindo apenas no mecanismo de threading subjacente.
        \item \texttt{/threads/gc}: Endpoint auxiliar para executar manualmente o processo de garbage collection.
    \end{itemize}

    A espera de 100 ms foi escolhida para simular operações I/O-bound típicas de aplicações web reais, como consultas a bancos de dados ou chamadas a serviços externos. Esse tempo de bloqueio permite avaliar como cada mecanismo de threads lida com alta concorrência em cenários onde threads frequentemente aguardam operações de entrada/saída.

    \section {Teste de Carga Constante}

    Esse teste possui o objetivo de avaliar a estabilidade e o desempenho dos mecanismos de \textit{threads} sob uma carga constante ao longo do tempo. A carga foi mantida em um nível fixo, permitindo observar como cada mecanismo lida com a concorrência e o consumo de recursos em um cenário estável.

    O teste foi realizados da seguinte maneira:

    \begin{enumerate}
        \item Três séries de aquecimento (\textit{warmup}) com 300 requisições por segundo durante 60 segundos.
        \item Aquecimento (\textit{warmup}) com 1000 requisições por segundo durante 120 segundos.
        \item Pausa de 60 segundos.
        \item Coleta de lixo (\textit{garbage collection}) manual na máquina servidor.
        \item Pausa de 20 segundos.
        \item Teste principal com 1000 requisições por segundo durante 600 segundos.
        \item Pausa de 60 segundos.
        \item Repetição dos passos 1 a 7 para o outro mecanismo de threads, em uma nova instância da JVM.
    \end{enumerate}

    A taxa de 1.000 requisições/segundo foi definida após testes preliminares que identificaram esse valor foi definido após testes preliminares que indicaram que a máquina servidor começava a apresentar erros de conexão acima dessa taxa. A duração de 10 minutos permite observar tendências de longo prazo, como degradação gradual de desempenho ou acúmulo de recursos.

    O teste foi repetido 45 vezes para cada mecanismo de threads, totalizando 90 execuções. Cada execução completa (ambos os mecanismos) durou aproximadamente 35 minutos, resultando em aproximadamente 27 horas de experimentação total.

    \section {Teste de carga com aumento gradual (\textit{ramp up})}

    O objetivo desse teste foi identificar o ponto em que o servidor começa a apresentar erros de conexão, indicando que atingiu seu limite máximo de requisições processáveis. 

    O teste foi conduzido da seguinte maneira:

    \begin{enumerate}
        \item \textbf{Warmup:}
        \begin{enumerate}
            \item Aquecimento com 300 requisições por segundo durante 60 segundos.
            \item Pausa de 60 segundos.
            \item Coleta de lixo (\textit{garbage collection}) manual na máquina servidor.
            \item Pausa de 20 segundos.
            \item Repetição dos passos acima mais duas vezes, com a taxa ajustada para 1000 requisições por segundo (limite seguro do servidor previamente testado).
        \end{enumerate}

        \item \textbf{Teste principal:}
        \begin{enumerate}
            \item Envio de requisições na taxa definida durante 10 segundos.
            \item Pausa de 60 segundos.
            \item Coleta de lixo (\textit{garbage collection}) manual na máquina servidor.
            \item Pausa de 20 segundos.
            \item Aumento da taxa em 50 requisições por segundo.
            \item Repetição dos passos acima até que o servidor comece a apresentar erros de conexão.
        \end{enumerate}
        \item Pausa de 60 segundos.
        \item Repetição dos passos 1 e 2 para o outro mecanismo de threads, em uma nova instância da JVM.
    \end{enumerate}

    O teste foi finalizado quando o servidor apresentou falhas em três execuções consecutivas, indicando saturação consistente do sistema.

    Este teste também foi repetido 45 vezes para cada mecanismo. A duração variou conforme o ponto de saturação: em média, 1 hora e 48 minutos para threads virtuais e 1 hora e 39 minutos para threads tradicionais. O tempo total de experimentação foi de aproximadamente 155 horas.

    \section{Controles Experimentais}
    Para garantir a validade dos resultados, foram implementados os controles:

        \begin{enumerate}
            \item Garbage Collection Manual: Executado antes de cada teste para minimizar o impacto de coletas automáticas durante as medições. O protocolo incluiu aguardar 60 segundos após qualquer requisição antes da coleta, seguido de 20 segundos de estabilização.

            \item Alternância de Ordem: A sequência de execução alternava entre threads tradicionais e virtuais para evitar que efeitos de aquecimento da JVM ou mudanças graduais no sistema favorecessem um mecanismo.

            \item Automação: Scripts automatizados padronizaram tempos de warmup, pausas e coleta de lixo.

            \item Isolamento de Recursos: Ambas as máquinas foram dedicadas exclusivamente aos experimentos, sem outras aplicações ou serviços em execução.

            \item Replicabilidade: Todos os scripts e código-fonte estão disponíveis no repositório GitHub: https://github.com/StephanyeCunto/TCC_Java_Thread_Benchmark
        \end{enumerate}

    \section{Métricas Coletadas}

    As métricas foram coletadas em dois pontos: na máquina servidora e na máquina cliente.

    No servidor as métricas foram coletadas através do Java Flight Recorder (JFR), processadas com Java Mission Control (JMC):

    \begin{enumerate}
        \item Utilização média de CPU (\%)
        \item Consumo de memória RAM (MB)
        \item Utilização de heap da JVM (MB)
    \end{enumerate}

    Os dados foram salvos em arquivos `Monitor.jfr` para cada execução, permitindo análise do comportamento interno da aplicação.

    As métricas foram coletadas no cliente pela ferramenta Vegeta durante o envio de requisições:
    \begin{enumerate}
        \item Latência: mínima, máxima, média e percentis (P50, P90, P95, P99)
        \item Taxa de transferência (throughput)
        \item Taxa de amostragem
        \item Taxa de sucesso (\%)
        \item Volume de dados (bytes de entrada e saída)
    \end{enumerate}

    Esses dados foram exportados para arquivos JSON para análise e comparação entre os mecanismos de threads.

    \section{Tratamento de erros}

    Durante os experimentos, foram observados erros de conexão e tempo limite, todos os erros ocorreram devido à falta de resposta do servidor, indicando que o mesmo não conseguiu processar todas as requisições recebidas. Esses erros foram identificados através de tokens gerado pelo Vegeta. 

    Como exemplo, alguns erros observados:
    \begin{itemize}
        \item \texttt{EOF (Client.Timeout exceeded while awaiting headers)}
        \item \texttt{http: server closed idle connection (Client.Timeout exceeded while awaiting headers)}
        \item \texttt{context deadline exceeded (Client.Timeout exceeded while awaiting headers)}
    \end{itemize}

    Execuções que apresentaram erros foram mantidas, pois a presença de falhas indica o ponto de saturação do sistema, uma métrica relevante para avaliar escalabilidade.

    \section{Análise Estatística}

    Para avaliar a necessidade de repetições dos testes foi conduzida uma análise estatística baseada na execução de  múltiplas repetições dos experimentos e no calculo do intervalo de confiança (IC) das métricas principais, como latência média, utilização de CPU e consumo de memória. 
    Antes de calcular o intervalo de confiança foram removidos valores discrepantes (\textit{outliers}) utilizando o método do intervalo interquartil (IQR). Isso ajudou a reduzir a influência de variações extremas e obter estimativas mais representativas do comportamento do sistema.
    
    Os intervalos de confiança foram calculados utilizando a distribuição t de Student, conforme a Equação~\ref{eq:ic}:

    \begin{equation}
        \label{eq:ic}
        IC = \bar{x} \pm t_{\alpha/2,\,gl} \cdot \frac{s}{\sqrt{n}}
        = \bar{x} \pm \text{Margem de Erro}
    \end{equation}

    Onde:
    \begin{itemize}
        \item $\bar{x}$ é a média amostral da métrica analisada;
        \item $t_{\alpha/2,\,gl}$ é o valor crítico da distribuição t de Student para um determinado nível de confiança e graus de liberdade;
        \item $s$ é o desvio padrão amostral;
        \item $n$ é o tamanho da amostra (número de execuções);
        \item $gl = n - 1$ representa os graus de liberdade.
    \end{itemize}

    Os valores críticos de t foram obtidos a partir de tabelas estatísticas para os níveis de confiança desejados (95\% e 99\%) e os graus de liberdade correspondentes. Com isso, foi possível calcular a margem de erro e o intervalo de confiança para cada métrica.

  \begin{table}[H]
    \centering
    \caption{Intervalos de confiança das métricas principais para o teste de carga constante}
    \label{tab:ic_metricas_principais}
    \begin{tabular}{lccccc}
    \hline
    \textbf{Mecanismo} & \textbf{IC} & \textbf{Lat. média (s)} & \textbf{CPU} & \textbf{Mem. (MB)} & \textbf{Heap (MB)} \\
    \hline
    Threads virtuais & 95\% & $[0{,}12,\ 0{,}14]$ & $[0{,}04,\ 0{,}04]$ & $[415{,}16,\ 519{,}46]$ & $[109{,}85,\ 173{,}56]$ \\
    Threads virtuais & 99\% & $[0{,}12,\ 0{,}15]$ & $[0{,}04,\ 0{,}04]$ & $[397{,}14,\ 537{,}48]$ & $[98{,}85,\ 184{,}56]$ \\
    \hline
    Threads trad. & 95\% & $[0{,}15,\ 0{,}23]$ & $[0{,}08,\ 0{,}08]$ & $[421{,}85,\ 525{,}78]$ & $[156{,}63,\ 219{,}25]$ \\
    Threads trad. & 99\% & $[0{,}14,\ 0{,}24]$ & $[0{,}08,\ 0{,}08]$ & $[403{,}79,\ 543{,}85]$ & $[145{,}74,\ 230{,}14]$ \\
    \hline
    \end{tabular}
    \begin{flushleft}
    \footnotesize
    Fonte: Elaboração própria.
    \end{flushleft}
    \end{table}
    A Tabela~\ref{tab:ic_metricas_principais} apresenta os intervalos de confiança calculados para as principais métricas do teste de carga constante. Observa-se que os intervalos são estreitos para latência média e para uso de cpu, indicando baixa variabilidade entre as execuções. 
    
    No entanto, os intervalos para consumo de memória e heap são mais amplos, sugerindo maior variação nesses aspectos o que era esperado devido à natureza dinâmica do gerenciamento de memória na JVM.

    Esses resultados indicam que o número de execuções adotado foi suficiente para capturar o comportamento médio do sistema de forma estatisticamente confiável, permitindo comparações consistentes entre threads tradicionais e threads virtuais.


    \section{Limitações dos Testes}

    Como já mencionado, os testes possue algumas limitacoes que devem ser consideradas na interpretação dos resultados:
    \begin{itemize}
        \item \textbf{Limitação de Hardware:} Não foi possível atingir os limites absolutos da máquina servidora, uma vez que o sistema operacional impôs restrições no número de requisições simultâneas. Os testes, portanto, caracterizam o limite do sistema operacional, não o limite de hardware.
        \item \textbf{Rede Wi-Fi:} A utilização de uma conexão Wi-Fi pode ter introduzido variabilidade adicionais de latência e perda de pacotes.Embora essa limitação afete ambos os mecanismos igualmente, testes em ambiente cabeado poderiam revelar diferenças mais sutis.
        \item \textbf{Ambiente Controlado:} Os testes foram realizados em um ambiente controlado com carga sintética e podem não refletir completamente o comportamento em ambientes de produção com cargas e padrões de uso variados.

        \item \textbf{Simplificação da Aplicação:} o servidor implementado utiliza apenas operações de espera (sleep), não incluindo operações I/O reais como acesso a banco de dados ou chamadas a serviços externos, o que pode limitar a generalização dos resultados
    \end{itemize}


    %     A diferença entre Metodologia, Procedimentos Metodológicos e Materiais e Métodos está mais no enfoque e na tradição da área do que em uma mudança drástica de significado. O aluno deve apresentar claramente como o trabalho foi realizado, para que outra pessoa possa entender e, se necessário, reproduzir a pesquisa.
    % \section{Metodologia}

    %     É o termo mais amplo e refere-se ao caminho adotado para realizar a pesquisa.

    %     Descreve o tipo de pesquisa (exploratória, descritiva, experimental etc.), a abordagem (qualitativa, quantitativa ou mista) e a estratégia geral utilizada.

    %     Envolve a justificativa das escolhas, por que esse método foi escolhido.

    % Exemplo: “Este estudo adotou uma abordagem quantitativa e experimental, utilizando simulações computacionais para avaliar o desempenho de diferentes algoritmos de roteamento.”

    % \section{Procedimentos Metodológicos}

    %     É um termo mais usado nas Ciências Humanas e Sociais. Tem foco no passo a passo da pesquisa: como os dados foram coletados, quais instrumentos foram usados e como a análise foi feita. É mais descritivo e menos técnico do que “Materiais e Métodos”.

    % Exemplo: “Para a coleta de dados, foram aplicados questionários estruturados a 50 participantes. As respostas foram analisadas por meio de estatística descritiva e teste t de Student.”

    % \section{Materiais e Métodos}

    %     É muito usado nas Ciências Exatas, Biológicas e Engenharias. Apresenta de forma técnica e detalhada os materiais, ferramentas, softwares, equipamentos ou reagentes utilizados; o passo a passo técnico para realizar o experimento ou implementação.

    %     Permite que outro pesquisador repita o estudo. 
        
    %     Exemplo: “O experimento utilizou cinco kits LEGO Mindstorms EV3, computadores com sistema operacional Linux e o software EV3 Classroom. Os testes foram conduzidos em laboratório controlado, com turmas de no máximo dez alunos por sessão.”


    \chapter{Aplicação / Implementação / Experimento}
    \label{chapter:resultados}

    Descrição passo a passo da execução do estudo.
    Apresentação de scripts, fluxogramas, diagramas ou imagens ilustrativas

    \chapter{Conclusão}
    \label{chapter:conclusao}

    A conclusão tem o papel de encerrar o trabalho, retomando de forma resumida o que foi feito e destacando as contribuições obtidas. Ela deve responder à pergunta central da pesquisa e deixar claro o que foi aprendido, comprovado ou desenvolvido.

    A conclusão deve fechar o trabalho com chave de ouro, respondendo à pergunta de pesquisa, destacando o que foi aprendido e mostrando como o estudo contribui para a área, além de abrir portas para novas pesquisas. 

    \begin{itemize}
        \item Relembre brevemente o objetivo geral do estudo e confirme se ele foi atingido.
        \item Destaque os resultados mais importantes, sem repetir tabelas ou gráficos.
        \item Foque no que é mais relevante para responder à questão de pesquisa.
        \item Interprete brevemente o que os resultados significam no contexto do problema.
        \item Falar das limitações do estudo é opcional, mas recomendado. Reconheça possíveis limitações que possam ter influenciado os resultados.
        \item Sugestões para trabalhos futuros. Indique possíveis melhorias ou novas abordagens que podem ser exploradas.
    \end{itemize}

    Não introduza informações novas que não tenham aparecido no desenvolvimento. Use tempo passado para descrever o que foi feito.

    \bookmarksetup{startatroot}% 
    
    ---------------------------------------------------------------------------------------------
    \postextual
    \bibliography{abntex2-modelo-references}

    %\begin{anexosenv}
        %\glossary
        %\begin{apendicesenv}
            %\partapendices
            %\chapter{Quadros de horários}
            %\label{chapter:apendice_quad_hor}
        %\end{apendicesenv}
    %\end{anexosenv}

\end{document}