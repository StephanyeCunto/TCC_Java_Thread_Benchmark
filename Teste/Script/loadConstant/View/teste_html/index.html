<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Benchmark Results - Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #7f8c8d;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .card h3 {
            color: #34495e;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .card-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .endpoint-stat {
            text-align: center;
        }

        .endpoint-label {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .endpoint-value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .traditional { color: #e74c3c; }
        .virtual { color: #27ae60; }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
        }

        .chart-container.full-width {
            grid-column: 1 / -1;
        }

        .chart-title {
            color: #2c3e50;
            font-size: 1.1em;
            margin-bottom: 15px;
            font-weight: 600;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th {
            background: #34495e;
            color: white;
            padding: 12px 8px;
            text-align: center;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        th:hover {
            background: #2c3e50;
        }

        th.sortable::after {
            content: ' ‚áÖ';
            opacity: 0.3;
        }

        th.sort-asc::after {
            content: ' ‚ñ≤';
            opacity: 1;
        }

        th.sort-desc::after {
            content: ' ‚ñº';
            opacity: 1;
        }

        td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid #ecf0f1;
            font-size: 0.9em;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .traditional-row {
            background: #fee;
        }

        .virtual-row {
            background: #efe;
        }

        .alert {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .alert-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #856404;
        }

        canvas {
            max-height: 400px;
        }

        .error {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä An√°lise de Performance - Benchmark</h1>
        <p class="subtitle">Compara√ß√£o entre Traditional vs Virtual Threads</p>

        <div class="loading" id="loading">Carregando dados dos testes...</div>

        <div id="content" style="display: none;">
            <div class="summary-cards" id="summaryCards"></div>

            <div class="alert">
                <div class="alert-title">‚ö†Ô∏è Observa√ß√µes Importantes</div>
                <div id="alertContent">Carregando an√°lise...</div>
            </div>

            <div class="charts-grid">
                <div class="chart-container full-width">
                    <div class="chart-title">Lat√™ncia M√©dia por Execu√ß√£o (clique nas barras para ocultar/exibir)</div>
                    <canvas id="latencyMeanChart"></canvas>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Distribui√ß√£o de Lat√™ncias (Percentis)</div>
                    <canvas id="percentilesChart"></canvas>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Throughput Comparativo (clique nas barras para ocultar/exibir)</div>
                    <canvas id="throughputChart"></canvas>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Taxa de Sucesso - Comparativo</div>
                    <canvas id="successChart"></canvas>
                </div>

                <div class="chart-container">
                    <div class="chart-title">Tempo de Espera (Wait Time) (clique nas barras para ocultar/exibir)</div>
                    <canvas id="waitChart"></canvas>
                </div>
            </div>

            <h2 style="margin: 40px 0 20px; color: #2c3e50;">üìã Dados Detalhados</h2>
            <table id="resultsTable">
                <thead>
                    <tr>
                        <th class="sortable" data-column="exec">Exec</th>
                        <th class="sortable" data-column="endpoint">Endpoint</th>
                        <th class="sortable" data-column="latMean">Lat. M√©dia (s)</th>
                        <th class="sortable" data-column="p50">P50 (s)</th>
                        <th class="sortable" data-column="p90">P90 (s)</th>
                        <th class="sortable" data-column="p95">P95 (s)</th>
                        <th class="sortable" data-column="p99">P99 (s)</th>
                        <th class="sortable" data-column="throughput">Throughput</th>
                        <th class="sortable" data-column="requests">Requests</th>
                        <th class="sortable" data-column="success">Sucesso (%)</th>
                        <th class="sortable" data-column="wait">Wait (s)</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <script>
        let allData = [];
        let sortColumn = null;
        let sortDirection = 'asc';
        
        // Track hidden data points for each chart
        let hiddenDataPoints = {
            latencyMean: new Set(),
            throughput: new Set(),
            wait: new Set(),
            success: new Set(),
            percentiles: new Set()
        };
        
        // Track hidden datasets (entire endpoint)
        let hiddenDatasets = {
            latencyMean: new Set(),
            throughput: new Set(),
            wait: new Set(),
            success: new Set(),
            percentiles: new Set()
        };
        
        // Store chart instances
        let chartInstances = {};

        // Load data from JSON files
        async function loadAllData() {
            const endpoints = ['traditional', 'virtual'];
            const executions = {
                traditional: [1, 3, 5, 7, 9],
                virtual: [2, 4, 6, 8, 10]
            };

            const promises = [];

            for (const endpoint of endpoints) {
                for (const exec of executions[endpoint]) {
                    const path = `./../Results/results/${endpoint}/${exec}/run/json/run${exec}.json`;
                    promises.push(
                        fetch(path)
                            .then(res => res.ok ? res.json() : null)
                            .then(data => {
                                if (data) {
                                    return {
                                        exec,
                                        endpoint,
                                        latMean: nsToSec(data.latencies?.mean),
                                        p50: nsToSec(data.latencies?.['50th']),
                                        p90: nsToSec(data.latencies?.['90th']),
                                        p95: nsToSec(data.latencies?.['95th']),
                                        p99: nsToSec(data.latencies?.['99th']),
                                        rate: data.rate,
                                        throughput: data.throughput,
                                        requests: data.requests,
                                        success: data.success * 100,
                                        duration: nsToSec(data.duration),
                                        wait: nsToSec(data.wait)
                                    };
                                }
                                return null;
                            })
                            .catch(err => {
                                console.error(`Erro ao carregar ${path}:`, err);
                                return null;
                            })
                    );
                }
            }

            const results = await Promise.all(promises);
            allData = results.filter(d => d !== null).sort((a, b) => a.exec - b.exec);

            if (allData.length === 0) {
                document.getElementById('loading').innerHTML = 
                    '<div class="error">‚ùå N√£o foi poss√≠vel carregar os dados. Verifique se os arquivos JSON est√£o no caminho correto.</div>';
                return;
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('content').style.display = 'block';

            renderAll();
        }

        function nsToSec(ns) {
            return ns !== undefined && ns !== null ? ns / 1e9 : null;
        }

        function renderAll() {
            createSummaryCards();
            createAlert();
            renderCharts();
            renderTable();
            setupTableSort();
        }

        // Summary Cards
        function createSummaryCards() {
            const traditional = allData.filter(d => d.endpoint === 'traditional');
            const virtual = allData.filter(d => d.endpoint === 'virtual');

            const tradGood = traditional.filter(d => d.success > 95);
            const virtGood = virtual.filter(d => d.success > 95);

            const avgLatTrad = tradGood.reduce((s, d) => s + d.latMean, 0) / tradGood.length;
            const avgLatVirt = virtGood.reduce((s, d) => s + d.latMean, 0) / virtGood.length;

            const avgThroughputTrad = tradGood.reduce((s, d) => s + d.throughput, 0) / tradGood.length;
            const avgThroughputVirt = virtGood.reduce((s, d) => s + d.throughput, 0) / virtGood.length;

            const summaryHTML = `
                <div class="card">
                    <h3>Lat√™ncia M√©dia (Execu√ß√µes Est√°veis)</h3>
                    <div class="card-content">
                        <div class="endpoint-stat">
                            <div class="endpoint-label">Traditional</div>
                            <div class="endpoint-value traditional">${avgLatTrad.toFixed(2)}s</div>
                        </div>
                        <div class="endpoint-stat">
                            <div class="endpoint-label">Virtual</div>
                            <div class="endpoint-value virtual">${avgLatVirt.toFixed(2)}s</div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h3>Throughput M√©dio</h3>
                    <div class="card-content">
                        <div class="endpoint-stat">
                            <div class="endpoint-label">Traditional</div>
                            <div class="endpoint-value traditional">${avgThroughputTrad.toFixed(0)}</div>
                        </div>
                        <div class="endpoint-stat">
                            <div class="endpoint-label">Virtual</div>
                            <div class="endpoint-value virtual">${avgThroughputVirt.toFixed(0)}</div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h3>Taxa de Sucesso</h3>
                    <div class="card-content">
                        <div class="endpoint-stat">
                            <div class="endpoint-label">Traditional</div>
                            <div class="endpoint-value traditional">${(tradGood.length / traditional.length * 100).toFixed(0)}%</div>
                            <div class="endpoint-label" style="font-size: 0.75em;">${tradGood.length}/${traditional.length} est√°veis</div>
                        </div>
                        <div class="endpoint-stat">
                            <div class="endpoint-label">Virtual</div>
                            <div class="endpoint-value virtual">${(virtGood.length / virtual.length * 100).toFixed(0)}%</div>
                            <div class="endpoint-label" style="font-size: 0.75em;">${virtGood.length}/${virtual.length} est√°veis</div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h3>Melhoria Virtual vs Traditional</h3>
                    <div class="card-content">
                        <div class="endpoint-stat">
                            <div class="endpoint-label">Lat√™ncia</div>
                            <div class="endpoint-value virtual">${((1 - avgLatVirt/avgLatTrad) * 100).toFixed(1)}%</div>
                            <div class="endpoint-label" style="font-size: 0.75em;">mais r√°pido</div>
                        </div>
                        <div class="endpoint-stat">
                            <div class="endpoint-label">Throughput</div>
                            <div class="endpoint-value virtual">+${((avgThroughputVirt/avgThroughputTrad - 1) * 100).toFixed(1)}%</div>
                            <div class="endpoint-label" style="font-size: 0.75em;">maior</div>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('summaryCards').innerHTML = summaryHTML;
        }

        // Alert Analysis
        function createAlert() {
            const traditional = allData.filter(d => d.endpoint === 'traditional');
            const failures = traditional.filter(d => d.success < 90);
            const alertHTML = `
                <strong>Traditional endpoint apresentou ${failures.length} execu√ß√µes com problemas graves:</strong>
                <ul style="margin-top: 10px; margin-left: 20px;">
                    ${failures.map(d => `<li>Execu√ß√£o ${d.exec}: ${d.success.toFixed(1)}% sucesso, lat√™ncia m√©dia ${d.latMean.toFixed(1)}s</li>`).join('')}
                </ul>
                <p style="margin-top: 10px;"><strong>Recomenda√ß√£o:</strong> Virtual threads mostram performance superior e mais est√°vel. Traditional precisa de investiga√ß√£o para identificar gargalos.</p>
            `;
            document.getElementById('alertContent').innerHTML = alertHTML;
        }

        // Charts
        const chartColors = {
            traditional: '#e74c3c',
            virtual: '#27ae60'
        };

        function getVisibleData(chartKey, dataArray, valueKey) {
            return dataArray.map((d, index) => {
                if (hiddenDataPoints[chartKey].has(index)) {
                    return d[valueKey]; // Keep the value but with reduced opacity
                }
                return d[valueKey];
            });
        }

        function getBackgroundColors(chartKey, dataArray) {
            return dataArray.map((d, index) => {
                const baseColor = d.endpoint === 'traditional' ? chartColors.traditional : chartColors.virtual;
                
                // Check if entire dataset is hidden
                if (hiddenDatasets[chartKey].has(d.endpoint)) {
                    return 'transparent';
                }
                
                // Check if individual point is hidden
                if (hiddenDataPoints[chartKey].has(index)) {
                    return baseColor + '30'; // Reduced opacity
                }
                return baseColor;
            });
        }

        function updateChartScale(chart, chartKey, valueKey) {
            const visibleValues = allData
                .map((d, index) => {
                    if (hiddenDatasets[chartKey].has(d.endpoint)) return null;
                    if (hiddenDataPoints[chartKey].has(index)) return null;
                    return d[valueKey];
                })
                .filter(v => v !== null);
            
            if (visibleValues.length > 0) {
                const maxValue = Math.max(...visibleValues);
                chart.options.scales.y.max = maxValue * 1.1; // Add 10% padding
            } else {
                delete chart.options.scales.y.max;
            }
            chart.update();
        }

        function renderCharts() {
            const traditional = allData.filter(d => d.endpoint === 'traditional');
            const virtual = allData.filter(d => d.endpoint === 'virtual');

            // 1. Latency Mean by Execution
            const latencyCtx = document.getElementById('latencyMeanChart');
            if (chartInstances.latencyMean) {
                chartInstances.latencyMean.destroy();
            }
            chartInstances.latencyMean = new Chart(latencyCtx, {
                type: 'bar',
                data: {
                    labels: allData.map(d => `#${d.exec}`),
                    datasets: [{
                        label: 'Lat√™ncia M√©dia',
                        data: getVisibleData('latencyMean', allData, 'latMean'),
                        backgroundColor: getBackgroundColors('latencyMean', allData)
                    }]
                },
                options: {
                    responsive: true,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            if (hiddenDataPoints.latencyMean.has(index)) {
                                hiddenDataPoints.latencyMean.delete(index);
                            } else {
                                hiddenDataPoints.latencyMean.add(index);
                            }
                            chartInstances.latencyMean.data.datasets[0].data = getVisibleData('latencyMean', allData, 'latMean');
                            chartInstances.latencyMean.data.datasets[0].backgroundColor = getBackgroundColors('latencyMean', allData);
                            updateChartScale(chartInstances.latencyMean, 'latencyMean', 'latMean');
                        }
                    },
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: {
                                generateLabels: (chart) => {
                                    return [
                                        {
                                            text: 'Traditional',
                                            fillStyle: hiddenDatasets.latencyMean.has('traditional') ? 'transparent' : chartColors.traditional,
                                            strokeStyle: chartColors.traditional,
                                            lineWidth: 2,
                                            hidden: hiddenDatasets.latencyMean.has('traditional')
                                        },
                                        {
                                            text: 'Virtual',
                                            fillStyle: hiddenDatasets.latencyMean.has('virtual') ? 'transparent' : chartColors.virtual,
                                            strokeStyle: chartColors.virtual,
                                            lineWidth: 2,
                                            hidden: hiddenDatasets.latencyMean.has('virtual')
                                        }
                                    ];
                                }
                            },
                            onClick: (event, legendItem) => {
                                const endpoint = legendItem.text.toLowerCase();
                                
                                if (hiddenDatasets.latencyMean.has(endpoint)) {
                                    hiddenDatasets.latencyMean.delete(endpoint);
                                } else {
                                    hiddenDatasets.latencyMean.add(endpoint);
                                }
                                
                                chartInstances.latencyMean.data.datasets[0].backgroundColor = getBackgroundColors('latencyMean', allData);
                                updateChartScale(chartInstances.latencyMean, 'latencyMean', 'latMean');
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const d = allData[ctx.dataIndex];
                                    return [
                                        `${d.endpoint}: ${d.latMean.toFixed(3)}s`,
                                        `Sucesso: ${d.success.toFixed(1)}%`,
                                        `Throughput: ${d.throughput.toFixed(0)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Lat√™ncia (segundos)' }
                        }
                    }
                }
            });

            // 2. Percentiles Comparison
            const tradGood = traditional.filter(d => d.success > 95);
            const virtGood = virtual.filter(d => d.success > 95);

            if (chartInstances.percentiles) {
                chartInstances.percentiles.destroy();
            }
            chartInstances.percentiles = new Chart(document.getElementById('percentilesChart'), {
                type: 'line',
                data: {
                    labels: ['P50', 'P90', 'P95', 'P99'],
                    datasets: [
                        {
                            label: 'Traditional',
                            data: [
                                tradGood.reduce((s, d) => s + d.p50, 0) / tradGood.length,
                                tradGood.reduce((s, d) => s + d.p90, 0) / tradGood.length,
                                tradGood.reduce((s, d) => s + d.p95, 0) / tradGood.length,
                                tradGood.reduce((s, d) => s + d.p99, 0) / tradGood.length
                            ],
                            borderColor: chartColors.traditional,
                            backgroundColor: chartColors.traditional + '20',
                            fill: true,
                            tension: 0.4,
                            hidden: false
                        },
                        {
                            label: 'Virtual',
                            data: [
                                virtGood.reduce((s, d) => s + d.p50, 0) / virtGood.length,
                                virtGood.reduce((s, d) => s + d.p90, 0) / virtGood.length,
                                virtGood.reduce((s, d) => s + d.p95, 0) / virtGood.length,
                                virtGood.reduce((s, d) => s + d.p99, 0) / virtGood.length
                            ],
                            borderColor: chartColors.virtual,
                            backgroundColor: chartColors.virtual + '20',
                            fill: true,
                            tension: 0.4,
                            hidden: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            onClick: (event, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);
                                
                                meta.hidden = !meta.hidden;
                                chart.update();
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Lat√™ncia (segundos)' }
                        }
                    }
                }
            });

            // 3. Throughput
            if (chartInstances.throughput) {
    chartInstances.throughput.destroy();
}

const orderedData = [...allData].sort((a, b) => a.exec - b.exec);

chartInstances.throughput = new Chart(
    document.getElementById('throughputChart'),
    {
        type: 'bar',
        data: {
            labels: orderedData.map(d => `#${d.exec}`),
            datasets: [
                {
                    label: 'Throughput',
                    data: orderedData.map(d => d.throughput),
                    backgroundColor: orderedData.map((d, i) => {
                        const color = d.endpoint === 'traditional'
                            ? chartColors.traditional
                            : chartColors.virtual;

                        if (hiddenDataPoints.throughput.has(i)) {
                            return color + '30';
                        }
                        return color;
                    })
                }
            ]
        },
        options: {
            responsive: true,
            onClick: (event, elements) => {
                if (!elements.length) return;

                const index = elements[0].index;

                if (hiddenDataPoints.throughput.has(index)) {
                    hiddenDataPoints.throughput.delete(index);
                } else {
                    hiddenDataPoints.throughput.add(index);
                }

                chartInstances.throughput.data.datasets[0].backgroundColor =
                    orderedData.map((d, i) => {
                        const color = d.endpoint === 'traditional'
                            ? chartColors.traditional
                            : chartColors.virtual;

                        return hiddenDataPoints.throughput.has(i)
                            ? color + '30'
                            : color;
                    });

                const visibleValues = orderedData
                    .filter((_, i) => !hiddenDataPoints.throughput.has(i))
                    .map(d => d.throughput);

                if (visibleValues.length > 0) {
                    chartInstances.throughput.options.scales.y.max =
                        Math.max(...visibleValues) * 1.1;
                } else {
                    delete chartInstances.throughput.options.scales.y.max;
                }

                chartInstances.throughput.update();
            },
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        generateLabels: () => [
                            {
                                text: 'Traditional',
                                fillStyle: chartColors.traditional,
                                strokeStyle: chartColors.traditional
                            },
                            {
                                text: 'Virtual',
                                fillStyle: chartColors.virtual,
                                strokeStyle: chartColors.virtual
                            }
                        ]
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Requests/segundo'
                    }
                }
            }
        }
    }
);


            // 4. Success Rate - GR√ÅFICO DE BARRAS
 if (chartInstances.success) {
    chartInstances.success.destroy();
}

chartInstances.success = new Chart(
    document.getElementById('successChart'),
    {
        type: 'bar',
        data: {
            labels: orderedData.map(d => `#${d.exec}`),
            datasets: [
                {
                    label: 'Taxa de Sucesso',
                    data: orderedData.map(d => d.success),
                    backgroundColor: orderedData.map((d, i) => {
                        const color = d.endpoint === 'traditional'
                            ? chartColors.traditional
                            : chartColors.virtual;

                        // Se o ponto est√° oculto, retorna uma cor mais clara
                        return hiddenDataPoints.success.has(i) ? color + '30' : color;
                    })
                }
            ]
        },
        options: {
            responsive: true,
            onClick: (event, elements) => {
                if (elements.length > 0) {
                    const index = elements[0].index;

                    // Alterna entre ocultar e mostrar os pontos clicados
                    if (hiddenDataPoints.success.has(index)) {
                        hiddenDataPoints.success.delete(index);
                    } else {
                        hiddenDataPoints.success.add(index);
                    }

                    // Atualiza os dados de cor e os valores vis√≠veis
                    chartInstances.success.data.datasets[0].backgroundColor =
                        orderedData.map((d, i) => {
                            const color = d.endpoint === 'traditional'
                                ? chartColors.traditional
                                : chartColors.virtual;
                            return hiddenDataPoints.success.has(i) ? color + '30' : color;
                        });

                    // Calcula o novo valor m√°ximo e m√≠nimo para o eixo Y
                    const visibleValues = orderedData
                        .filter((_, i) => !hiddenDataPoints.success.has(i))
                        .map(d => d.success);

                    if (visibleValues.length > 0) {
                        const minVal = Math.min(...visibleValues);
                        const maxVal = Math.max(...visibleValues);
                        chartInstances.success.options.scales.y.min = Math.max(0, minVal - 5);
                        chartInstances.success.options.scales.y.max = Math.min(100, maxVal + 5);
                    } else {
                        chartInstances.success.options.scales.y.min = 0;
                        chartInstances.success.options.scales.y.max = 100;
                    }

                    chartInstances.success.update();
                }
            },

            plugins: {
                legend: {
    display: true,
    position: 'top',
    labels: {
        generateLabels: () => [
            {
                text: 'Traditional',
                fillStyle: hiddenDatasets.success.has('traditional')
                    ? 'transparent'
                    : chartColors.traditional,
                strokeStyle: chartColors.traditional,
                lineWidth: 2
            },
            {
                text: 'Virtual',
                fillStyle: hiddenDatasets.success.has('virtual')
                    ? 'transparent'
                    : chartColors.virtual,
                strokeStyle: chartColors.virtual,
                lineWidth: 2
            }
        ]
    },
    onClick: (event, legendItem) => {
        const endpoint = legendItem.text.toLowerCase();

        // alterna estado do dataset
        const isHidden = hiddenDatasets.success.has(endpoint);

        if (isHidden) {
            hiddenDatasets.success.delete(endpoint);
        } else {
            hiddenDatasets.success.add(endpoint);
        }

        // aplica o mesmo efeito do clique manual
        orderedData.forEach((d, index) => {
            if (d.endpoint === endpoint) {
                if (isHidden) {
                    hiddenDataPoints.success.delete(index);
                } else {
                    hiddenDataPoints.success.add(index);
                }
            }
        });

        // atualiza cores
        chartInstances.success.data.datasets[0].backgroundColor =
            orderedData.map((d, i) => {
                const color = d.endpoint === 'traditional'
                    ? chartColors.traditional
                    : chartColors.virtual;

                return hiddenDataPoints.success.has(i) ? color + '30' : color;
            });

        // recalcula escala Y
        const visibleValues = orderedData
            .filter((_, i) => !hiddenDataPoints.success.has(i))
            .map(d => d.success);

        if (visibleValues.length > 0) {
            chartInstances.success.options.scales.y.min =
                Math.max(0, Math.min(...visibleValues) - 5);
            chartInstances.success.options.scales.y.max =
                Math.min(100, Math.max(...visibleValues) + 5);
        } else {
            chartInstances.success.options.scales.y.min = 0;
            chartInstances.success.options.scales.y.max = 100;
        }

        chartInstances.success.update();
    }
}

            },

            scales: {
                y: {
                    min: 0,
                    max: 100,
                    title: {
                        display: true,
                        text: 'Taxa de Sucesso (%)'
                    }
                }
            }
        }
    }
);


            // 5. Wait Time
            if (chartInstances.wait) {
                chartInstances.wait.destroy();
            }
            chartInstances.wait = new Chart(document.getElementById('waitChart'), {
                type: 'bar',
                data: {
                    labels: allData.map(d => `#${d.exec}`),
                    datasets: [{
                        label: 'Wait Time',
                        data: getVisibleData('wait', allData, 'wait'),
                        backgroundColor: getBackgroundColors('wait', allData)
                    }]
                    
                },
                options: {
                    responsive: true,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            if (hiddenDataPoints.wait.has(index)) {
                                hiddenDataPoints.wait.delete(index);
                            } else {
                                hiddenDataPoints.wait.add(index);
                            }
                            chartInstances.wait.data.datasets[0].data = getVisibleData('wait', allData, 'wait');
                            chartInstances.wait.data.datasets[0].backgroundColor = getBackgroundColors('wait', allData);
                            updateChartScale(chartInstances.wait, 'wait', 'wait');
                        }
                    },
                    plugins: { 
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: {
                                generateLabels: (chart) => {
                                    return [
                                        {
                                            text: 'Traditional',
                                            fillStyle: hiddenDatasets.wait.has('traditional') ? 'transparent' : chartColors.traditional,
                                            strokeStyle: chartColors.traditional,
                                            lineWidth: 2,
                                            hidden: hiddenDatasets.wait.has('traditional')
                                        },
                                        {
                                            text: 'Virtual',
                                            fillStyle: hiddenDatasets.wait.has('virtual') ? 'transparent' : chartColors.virtual,
                                            strokeStyle: chartColors.virtual,
                                            lineWidth: 2,
                                            hidden: hiddenDatasets.wait.has('virtual')
                                        }
                                    ];
                                }
                            },
                            onClick: (event, legendItem) => {
                                const endpoint = legendItem.text.toLowerCase();
                                
                                if (hiddenDatasets.wait.has(endpoint)) {
                                    hiddenDatasets.wait.delete(endpoint);
                                } else {
                                    hiddenDatasets.wait.add(endpoint);
                                }
                                
                                chartInstances.wait.data.datasets[0].backgroundColor = getBackgroundColors('wait', allData);
                                updateChartScale(chartInstances.wait, 'wait', 'wait');
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Tempo de Espera (s)' }
                        }
                    }
                }
            });
        }

        // Table
        function renderTable() {
            const tbody = document.querySelector('#resultsTable tbody');
            tbody.innerHTML = '';
            
            allData.forEach(d => {
                const row = tbody.insertRow();
                row.className = d.endpoint === 'traditional' ? 'traditional-row' : 'virtual-row';
                row.innerHTML = `
                    <td>${d.exec}</td>
                    <td><strong>${d.endpoint}</strong></td>
                    <td>${d.latMean.toFixed(3)}</td>
                    <td>${d.p50.toFixed(3)}</td>
                    <td>${d.p90.toFixed(3)}</td>
                    <td>${d.p95.toFixed(3)}</td>
                    <td>${d.p99.toFixed(3)}</td>
                    <td>${d.throughput.toFixed(2)}</td>
                    <td>${d.requests.toLocaleString()}</td>
                    <td>${d.success.toFixed(2)}</td>
                    <td>${d.wait.toFixed(3)}</td>
                `;
            });
        }

        // Table Sorting
        function setupTableSort() {
            const headers = document.querySelectorAll('th.sortable');
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.dataset.column;
                    
                    if (sortColumn === column) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = column;
                        sortDirection = 'asc';
                    }

                    // Update header classes
                    headers.forEach(h => {
                        h.classList.remove('sort-asc', 'sort-desc');
                    });
                    header.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

                    // Sort data
                    allData.sort((a, b) => {
                        let valA = a[column];
                        let valB = b[column];

                        if (typeof valA === 'string') {
                            valA = valA.toLowerCase();
                            valB = valB.toLowerCase();
                        }

                        if (sortDirection === 'asc') {
                            return valA > valB ? 1 : valA < valB ? -1 : 0;
                        } else {
                            return valA < valB ? 1 : valA > valB ? -1 : 0;
                        }
                    });

                    renderTable();
                });
            });
        }

        // Load data on page load
        loadAllData();
    </script>
</body>
</html>
