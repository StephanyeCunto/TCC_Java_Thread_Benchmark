\documentclass[12pt, openright, oneside, a4paper, brazil]{abntex2}

\usepackage{fontspec}
\usepackage{graphicx}			
\usepackage{xcolor}	
\usepackage{microtype} 			
\usepackage{setspace}
\usepackage{indentfirst}		
\usepackage{float}
\usepackage{caption}
\usepackage{tabularx}  
\usepackage{pdflscape}  
\usepackage{geometry}

\geometry{left=2cm, right=2cm, top=2cm, bottom=2cm}

\newfloat{quadro}{htbp}{loq}[section]
\floatname{quadro}{Quadro}
\captionsetup[quadro]{font=small, labelfont=bf, labelsep=period}

\begin{document}

\begin{landscape}

% ===========================
% TABELA 1
% ===========================
\begin{quadro}[H]
    \centering
    \caption{Trabalhos relacionados (Parte 1)}
    \fontsize{10}{12}\selectfont
    \begin{tabularx}{\linewidth}{|p{3cm}|p{2.2cm}|p{2cm}|p{2.2cm}|p{1cm}|p{1.3cm}|p{4cm}|p{3cm}|X|}
        \hline
        \textbf{Nome} & \textbf{Métricas} & \textbf{Benchmark} & \textbf{Warmup}  & \textbf{Exec.} & \textbf{Excl.} & \textbf{Res.} & \textbf{O que comparou} & \textbf{Teste} \\ \hline
        
        Comparison of Concurrency Technologies in Java & 
        Latência, taxa de transferência, taxa de amostragem, respostas do servidor, bytes de entrada e saída. &
        Não Informado &
        Três execuções de 60s, cada uma com 300 requisições/seg. Uma execução de 2min, usando a taxa real do teste.& 
        5 & 
        Outliers & 
        \begin{minipage}[t]{\linewidth}
            Computation Test (CPU-bound): \\
            Threads tradicionais tiveram o melhor desempenho em throughput e latência. \\
            I/O Test (I/O-bound): \\
            O reactive Framework teve maior escalabilidade, menor uso de CPU e memória. \\
            Mixed Test – Computation focused: \\
            As threads virtuais tiveram alta taxa de requisições e baixa latência. \\
            Mixed Test – I/O focused: \\
            As threads virtuais mantiveram desempenho alto, enquanto as tradicionais tiveram alta latência e menor throughput. \\
        \end{minipage} & 
        Threads tradicionais, virtuais e reactive Framework em teste de I/O-Bound, CPU-Bound e testes mistos & 
        \begin{minipage}[t]{\linewidth}
            I/O Test – Thread.sleep(100 ms).\\
            Computation Test – Multiplica matrizes 200×200.\\
            Mixed Test – Multiplica matrizes 200×200 + pausa curta (25 ms).\\
            Mixed Test – I/O focused – Multiplica matrizes 50×50 + pausa longa (100 ms).\\ 
        \end{minipage} \\
        \hline
        
        Avaliação dos mecanismos de concorrência na API do Java 8 & 
        \begin{minipage}[t]{\linewidth}
            Tempo de execução (μs) \\
            Consumo de memória (MB)
        \end{minipage} &
        Não informado &
        \begin{minipage}[t]{\linewidth}
            Não informado, talvez 10 \\
            Página 48  
        \end{minipage} &
        60 & 
        Não Houve & 
        Quicksort com ForkJoinPool em máquina com 8 processadores lógicos obteve o melhor resultado em tempo, Quicksort e ForkJoinPool apresentaram os menores tempos na maioria dos cenários. &
        Os algoritmos Quicksort, Mergesort e Pidgeonholesort com single thread, threads, executorService e fork/Join em dual-core, i5 e i7 &
        CPU-bound \\
        \hline
    \end{tabularx}
\end{quadro}

% ===========================
% TABELA 2
% ===========================
\begin{quadro}[H]
    \centering
    \caption{Trabalhos relacionados (Parte 2)}
    \fontsize{10}{12}\selectfont
    \begin{tabularx}{\linewidth}{|p{3cm}|p{2.2cm}|p{2cm}|p{2.2cm}|p{1cm}|p{1.3cm}|p{4cm}|p{3cm}|X|}
        \hline
        \textbf{Nome} & \textbf{Métricas} & \textbf{Benchmark} & \textbf{Warmup}  & \textbf{Exec.} & \textbf{Excl.} & \textbf{Res.} & \textbf{O que comparou} & \textbf{Teste} \\ \hline
        
        Uma análise comparativa entre threads e green threads no Java & 
        Tempo de execução (μs) &
        Biblioteca JMH &
        1 & 
        30 & 
        Não Houve & 
        Threads virtuais foram pelo menos 10 vezes mais rápidas em todos os testes &
        Tempo de instanciar, iniciar, realizar join e troca de contexto em threads tradicionais e virtuais &
        \begin{minipage}[t]{\linewidth}
            CPU-bound \\
            I/O-bound (simulado): \\
            Criou 100.000 threads, cada thread aguarda 100 ms, invoca Thread.yield() e aguarda mais 100 ms.
        \end{minipage} \\
        \hline
        
        Benchmarking the Performance of Java Virtual Threads in High-Throughput Workloads & 
        Taxa de transferência (req/s), latência, uso CPU (\%) e memória &
        Não informado &
        \begin{minipage}[t]{\linewidth}
            CPU-bound: \\
            Usou 10 threads por 5 min para aquecer \\
            I/O-bound: 10 usuários concorrentes durante 60s
        \end{minipage} &
        3 &
        Execuções com erros de rede descartadas &
        \begin{minipage}[t]{\linewidth}
            CPU-bound: Threads tradicionais mais rápidas, maior uso de memória, ambas usaram 100\% da CPU, resultados semelhantes em latência e throughput \\
            I/O-bound: Threads virtuais mais rápidas, menor uso de memória e CPU, throughput maior, latência menor
        \end{minipage} &
        Threads virtuais e tradicionais em cálculo de números primos e requisições com ação bloqueante &
        \begin{minipage}[t]{\linewidth}
            CPU-bound: Calcular números primos em um intervalo \\
            I/O-bound: Duas aplicações Java: uma envia requisições (GET), outra simula operação bloqueante.
        \end{minipage} \\
        \hline
    \end{tabularx}
\end{quadro}

\end{landscape}

\end{document}
