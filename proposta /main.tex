% !TEX TS-program = lualatex
\documentclass[12pt,a4paper]{article}

% Pacotes básicos
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{setspace}
\onehalfspacing % Espaçamento 1,5

\title{Análise de Desempenho entre Threads Tradicionais e Threads Virtuais em Java}
\author{
    Stephanye Cristine Antunes De Cunto \\[1em]
   \large Orientadora: Me. Bianca Portes de Castro \\ 
    \large Coorientador: Dr. José Rui Castro de Sousa
}
\date{2025}

\begin{document}

\maketitle

\newpage

\section*{Proposta do TCC}

O Java possui diversas formas de criar uma thread, como herdando a classe \texttt{Thread}, implementando a interface funcional \texttt{Runnable} ou utilizando as interfaces \texttt{Callable} e \texttt{Future}. Com o lançamento do Java 19, foi introduzida uma nova abordagem: as threads virtuais. Diferentemente das threads tradicionais, que são gerenciadas pelo sistema operacional (SO), as threads virtuais são gerenciadas pela JVM (Java Virtual Machine).

O objetivo deste trabalho é analisar se existem diferenças de desempenho entre as técnicas de paralelização quando há uma alta carga. Para isso, serão comparadas threads tradicionais, gerenciadas pelo SO, e threads virtuais, gerenciadas pela JVM, com o intuito de avaliar o desempenho e o comportamento de cada abordagem.

Serão realizados dois benchmarks em ambiente controlado. O primeiro será CPU-bound, utilizando algoritmos como cálculo de números primos ou multiplicação de matrizes, onde se espera que a implementação com threads virtuais não apresente ganhos significativos em relação às threads tradicionais. O segundo será I/O-bound, com a implementação de um servidor HTTP que atenderá requisições simulando espera por meio de \texttt{Thread.sleep()}. Nesse caso, espera-se que as threads virtuais apresentem melhor desempenho, devido à sua menor sobrecarga e maior escalabilidade em operações de I/O.

As métricas a serem utilizadas incluem: tempo total de execução, throughput (requisições ou tarefas por segundo), uso médio de CPU e memória, e número de threads criadas. Para o benchmark CPU-bound será analisado o speedup, enquanto para o benchmark I/O-bound será avaliada a latência média.

Para a realização deste trabalho, serão utilizadas as seguintes ferramentas:
\begin{itemize}
    \item \textbf{JDK (Java Development Kit)}: fornecerá o ambiente necessário para compilação e execução dos programas em Java.
    \item \textbf{VisualVM}: será utilizado para monitoramento e análise de desempenho das aplicações.
    \item \textbf{Spring Boot}: será empregado na implementação do servidor HTTP para o benchmark I/O-bound.
\end{itemize}

Com isso, espera-se obter um relatório comparativo entre as técnicas, identificar os cenários em que cada modelo apresenta melhor desempenho e realizar uma discussão sobre as vantagens e desvantagens de cada abordagem.

\end{document}
