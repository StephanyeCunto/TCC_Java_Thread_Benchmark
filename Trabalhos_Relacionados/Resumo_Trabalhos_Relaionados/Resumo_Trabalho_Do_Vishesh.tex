\documentclass[12pt,a4paper]{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{booktabs} % Para tabelas com linhas horizontais mais bonitas
\usepackage{caption}

% Configura margens ABNT
\geometry{
  top=3cm,
  bottom=2cm,
  left=3cm,
  right=2cm
}

\onehalfspacing % Espaçamento 1,5

\begin{document}

\section*{Pergunta Central}
Qual tipo de thread apresenta melhor desempenho: a thread tradicional ou a thread virtual?

\section*{Objetivo}
Comparar o desempenho entre threads tradicionais e threads virtuais.

\section*{Ambiente}
Os experimentos foram realizados em uma máquina equipada com processador AMD® Ryzen 7 3700U, 20~GB de memória RAM, disco com capacidade de 256~GB, executando o sistema operacional Ubuntu 22.04.03~LTS.

\section*{Metodologia}
Cada método do microbenchmark foi executado 30 vezes, incluindo uma execução inicial adicional utilizada como fase de aquecimento.

\subsection*{Instanciação de Threads}
Mediu-se o tempo necessário para criar 100.000 threads por meio da chamada \texttt{new Thread()}.

\subsection*{Inicialização de Threads}
Mediu-se o tempo necessário para iniciar as 100.000 threads, utilizando \texttt{thread.start()}.

\subsection*{Finalização de Threads (Join)}
Foram criadas 10.000 threads, armazenadas em uma lista. Todas foram iniciadas e sincronizadas com \texttt{thread.join()} para medir o tempo total de finalização.

\subsection*{Mudança de Contexto (Yield)}
Mediu-se o tempo necessário para criar 100.000 threads, onde cada thread executa uma pausa de 100~ms e cede voluntariamente o controle da CPU por meio de \texttt{Thread.yield()}. Após a criação, todas as threads foram armazenadas em uma lista, iniciadas e finalizadas.  
Este procedimento avalia o comportamento cooperativo entre threads sob carga intensa, custo de troca de contexto quando utilizado \texttt{yield()}, impacto de operações bloqueantes leves e a capacidade em gerenciar 100.000 threads com pausas e cedências voluntárias.

\section*{Resultados}
Todos os microbenchmarks foram executados em aproximadamente 2 horas.  
A tabela~\ref{tab:resultados} apresenta os resultados obtidos:

\begin{table}[h!]
\centering
\caption{Resultados de Desempenho entre Threads Tradicionais e Virtuais}
\label{tab:resultados}
\begin{tabular}{lcc}
\toprule
Cenário & Thread Tradicional & Thread Virtual \\
\midrule
Instanciar Threads & 0,178~s & 0,001~s \\
Iniciar Threads & 1,099~s & 0,002~s \\
Finalizar Threads (Join) & 1,093~s & 0,002~s \\
Mudança de Contexto (Yield) & 14,216~s & 0,019~s \\
\bottomrule
\end{tabular}
\end{table}

Em ambos os microbenchmarks foi aplicado o teste \textit{t} de Student com nível de significância 0,05, obtendo um valor de \textit{p} próximo a 0, indicando uma diferença estatisticamente significativa entre os tempos médios.

\section*{Conclusão}
Os resultados obtidos demonstram que as threads virtuais podem ser mais de 100 vezes mais rápidas que as threads tradicionais nos cenários testados.

\section*{Ameaças à Validade}
O estudo focou em um único ambiente físico e utilizou uma carga de estresse particular. Caso a máquina fosse exposta a uma carga mais intensa, os resultados poderiam ser alterados. Da mesma forma, diferenças em processadores, quantidade de memória RAM, velocidade de disco e outros elementos físicos poderiam impactar a performance em outros ambientes.

\section*{Ferramentas}
\begin{itemize}
    \item JDK
    \item \texttt{org.openjdk.jmh} - biblioteca de benchmarking
    \item JMH BlackHole – utilizada para evitar que o compilador otimize ou ignore a instanciação de objetos
\end{itemize}

\end{document}
