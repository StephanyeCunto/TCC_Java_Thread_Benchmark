\documentclass[12pt]{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{array}
\usepackage{longtable}
\usepackage{tabularx}
\usepackage{booktabs}

\geometry{a4paper, margin=2.5cm}

\begin{document}


\section*{\normalsize Pergunta Central}
Como as trheads virtuais funcionam em comparação as threads tradicionais em termos de escalabilidade, utilização de recursos e latência em cargas de trabalho de alto rendimento?

\section*{\normalsize Objetivo}
Identificar os cenários cada modelo se destaca e fornecer dados concretos para decisões sobre adoção de Virtual Threads em aplicações Java.

\section*{\normalsize Implementação}
Foram desenvolvidas quatro aplicações Java independentes:

\begin{itemize}
    \item Threads Tradicionais – CPU-bound
    \item Threads Tradicionais – I/O-bound
    \item Threads Virtuais – CPU-bound
    \item Threads Virtuais – I/O-bound
\end{itemize}

\textbf{Benchmark 1 – CPU-bound:} Cáculo de números primos do limite inferior ao limite superior.

\textbf{Benchmark 2 – I/O-bound:} Simulação de operação de bloqueio criando duas aplicações Java. Um aplicativo faz um GET de requisição e recebe os resultados de outra aplicação Java, que leva um tempo específico de bloqueio e produz a resposta.

\section*{\normalsize Experimentos}
\begin{itemize}
    \item Ambiente controlado no AWS EC2, configurações: t3.xlarge, 4 vCPUs, 16 GB RAM, Ubuntu 22.04
    \item Repetições: cada teste realizado três vezes
    \item Warm-up:
    \begin{itemize}
        \item Benchmark 1 – carga de 10 threads por 5 minutos
        \item Benchmark 2 – fase de aquecimento de 10 usuários simultâneos por 60 segundos
    \end{itemize}
    \item Threads Virtuais: \texttt{Executors.newVirtualThreadPerTaskExecutor()}
    \item Threads tradicionais: \texttt{Executors.newFixedThreadPool()}
\end{itemize}

\subsection*{\normalsize Métricas de Desempenho}
\begin{itemize}
    \item Taxa de transferência
    \item Latência
    \item Uso de memória
    \item Utilização da CPU
\end{itemize}

\section*{\normalsize Ferramentas Utilizadas}
\begin{itemize}
    \item JDK 21
    \item Spring Boot 3.2
    \item IntelliJ IDEA
    \item Maven
    \item Apache JMeter: geração de carga e coleta de métricas
    \item VisualVM: monitoramento de CPU, heap e threads em tempo real
\end{itemize}

\section*{\normalsize Resultados}

\begin{tabularx}{\textwidth}{cXXXX}
    \toprule
    \textbf{Métrica} & \textbf{Tradicional - CPU} & \textbf{Virtual - CPU} & \textbf{Tradicional - I/O} & \textbf{Virtual - I/O} \\
    \midrule
    Taxa de transferência & 8204,1 req/seg & 8153,2 req/seg & 5410,1 req/seg & 8898,3 req/seg \\
    Latência & 121 ms & 118 ms & 448 ms & 319 ms \\
    Uso de memória & 1,5 GB & 1,3 GB & 2,2 GB & 1,4 GB \\
    Utilização da CPU & 94\% & 93\% & 72\% & 84\% \\
    \bottomrule
\end{tabularx}

\section*{\normalsize Conclusão}
Para cargas de trabalho com uso limitado de CPU: as threads virtuais e as threads de plataforma apresentam desempenho semelhantes. Tarefas com uso intensivo de CPU sofrem gargalos devido aos recursos computacionais, e o aumento da simultaneidade não terá muita importância.

Para cargas de trabalho vinculadas a I/O: As threads virtuais superaram as threads de plataforma em termos de taxa de transferência e latência. As Threads Virtuais permitiram maior simultaneidade, redução do consumo de memória e uma melhor utilização da CPU.

\section*{\normalsize Trabalhos Futuros}
\begin{itemize}
    \item Cenários de Carga de Trabalho Mista
    \item Integração com aplicativos nativos da nuvem
    \item Modelos reativos e assíncronos
\end{itemize}

\end{document}
